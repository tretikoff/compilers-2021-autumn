-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun binop (l, op, r) {
    Binop (op, l, r)
}

-- Primary expression
var primary = memo $ eta (decimal @ fun (x) {Const (stringInt (x))} |
                          lident  @ fun (x) {Var (x)} |
                          inbr (s ("("), exp, s (")"))),
    exp = memo $ eta expr ({
        [Left, {[s("!!"), binop]}],
        [Left, {[s("&&"), binop]}],
        [Left, {[s("==") | s("!=") | s("<") | s("<=") | s(">") | s(">="), binop]}],
        [Left, {[s("+") | s("-"), binop]}],
        [Left, {[s("*") | s("/") | s("%"), binop]}]
    }, primary);

--        If      (expr, stmt, stmt) |
--        While   (expr, stmt)       |
--        DoWhile (stmt, expr)

var simple = memo $ eta syntax (
     kSkip {Skip} |
     kRead v1 = inbr[s("("), lident, s(")")] {Read (v1)} |
     kWrite e1 = inbr[s("("), exp, s(")")] {Write (e1)} |
     v1 = lident s[":="] e1 = exp {Assn (v1, e1)} |
     kIf e = exp kThen s1 = stmt s2 = els {If (e, s1, s2)} |
--     kElif e1 = exp kThen s1 = stmt s2 = stmt {If (e1, s1, s2)} |
--     kElse s1 = stmt s1 kFi |
     kWhile e1 = exp kDo s1 = stmt kOd {While (e1, s1)} |
     kDo s = stmt kWhile e = exp kOd {DoWhile (s, e)} |
     kFor s1 = stmt s[","] e = exp s[","] s2 = stmt kDo s3 = stmt kOd {Seq (s1, While (e, Seq (s3, s2)))}
 );

var els = memo $ eta syntax (
    -kElse stmt -kFi |
    kElif e=exp kThen s1=stmt s2=els {If (e, s1, s2)} |
    kFi {Skip}
);

var stmt = memo $ eta syntax (
  s1=simple s[";"] s2=stmt {Seq (s1, s2)} |
  simple
);


-- Public top-level parser
public parse = stmt;
